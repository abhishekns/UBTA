#region File Header
/*[ Compilation unit ----------------------------------------------------------
    Component       : ubta
    Name            : CodeGen.cs
    Last Author     : Abhishek Sharma
    Language        : C#
    Creation Date   : 18. March 2010
    Description     : 

     
-----------------------------------------------------------------------------*/
/*] END */
#endregion
using System;
using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Xml;
using System.Xml.Schema;
using ubta.Common;

namespace ubta.ExecuterLib
{
    public class CodeGen
    {
        private const string Template = "using ${usingnamespace};\n"+
                                        "namespace ${namespace}\n"+
                                        "{\n"+
                                        "	public class ${executerName}Executer : AbstractExecuterBase<${executerName}>\n"+
                                        "	{\n"+
                                        "		/// <summary>\n"+
                                        "       /// This method is generated by CodeGen and will be overwritten if modified before calling CodeGen.GenerateExecuter.\n"+
                                        "       /// </summary>\n"+
                                        "		protected override void InitInternal()\n"+
                                        "		{\n"+
                                        "			${InitInternalCode}\n"+
                                        "		}\n"+
                                        "		\n"+
                                        "		/// <summary>\n"+
                                        "       /// This method executes the method described by the <c>anode_in<c>.\n"+
                                        "       /// </summary>\n"+
                                        "       /// <param name=\"anode_in\">The method node</param>\n"+
                                        "		public override ExecuteMethod(XmlNode anode_in)\n"+
                                        "		{\n"+
                                        "		${ExecuteMethodCode}\n"+
                                        "		}\n"+
                                        "		\n"+
                                        "		#region Generated Methods\n"+
                                        "		${GeneratedMethods}\n"+
                                        "		#endregion\n"+
                                        "	}\n"+
                                        "}\n";

        private VariableManager myVS = VariableManager.Instance;

        public CodeGen()
        {
            myVS["${usingnamespace}"] = "";
            myVS["${namespace}"] = "";
            myVS["${executerName}"] ="";
            myVS["${InitInternalCode}"] = "";
            myVS["${ExecuteMethodCode}"] = "";
            myVS["${GeneratedMethods}"] = "";
        }

        private StringBuilder myGeneratedMethods = new StringBuilder();

        public bool GenerateExecuter(XmlSchemaType xst)
        {
            XmlSchemaComplexType xsct = xst as XmlSchemaComplexType;
            List<XmlSchemaElement> methods = new List<XmlSchemaElement>();
            XmlSchemaChoice xsc = xsct.ContentTypeParticle as XmlSchemaChoice;
            if (null != xsc)
            {
                methods.AddRange(xsc.Items.Cast<XmlSchemaElement>());
            }
            StringBuilder sb = new StringBuilder();
            sb.AppendLine("switch(anode_in.Name)");
            sb.AppendLine("\t\t\t{");
            foreach (XmlSchemaElement xse in methods)
            {
                sb.AppendLine(string.Format("\t\t\tcase \"{0}\":", xse.Name));
                sb.AppendLine("\t\t\t\t{");
                sb.Append("\t\t\t\t\t");
                sb.AppendLine(GetExecutionStatement(xse));
                sb.AppendLine("\t\t\t\t\tbreak;");
                sb.AppendLine("\t\t\t\t}");
            }
            sb.AppendLine("\t\t\t}");
            myVS["${usingnamespace}"] = "System;";
            myVS["${namespace}"] = GetLastName(xsct.QualifiedName.Namespace, '/');
            myVS["${executerName}"] = GetLastName(xsct.Name, '.');
            myVS["${InitInternalCode}"] = "";
            myVS["${ExecuteMethodCode}"] = sb.ToString();
            myVS["${GeneratedMethods}"] = myGeneratedMethods.ToString();
            StringBuilder opfile = new StringBuilder();
            opfile.Append(Template);
            IDictionaryEnumerator de = myVS.Mapping;
            while(de.MoveNext())
            {
                string varname = de.Key as string;
                string val = de.Value as string;
                opfile.Replace(varname, val);
            }
            Console.WriteLine(opfile);
            return true;
        }

        private string GetLastName(string p, char c)
        {
            return p.Substring(p.LastIndexOf(c) + 1);
        }

        private string GetExecutionStatement(XmlSchemaElement xse)
        {
            StringBuilder sb = new StringBuilder();
            XmlSchemaComplexType args = xse.ElementSchemaType as XmlSchemaComplexType;
            if (null == args)
            {
                return string.Empty;
            }
            XmlSchemaSequence argseq = null;
            XmlSchemaChoice argChoice = null;
            
            if (null != (argseq = args.ContentTypeParticle as XmlSchemaSequence))
            {
                List<XmlSchemaElement> parameters = argseq.Items.Cast<XmlSchemaElement>().ToList<XmlSchemaElement>();
                sb.Append(GenerateMethodCallStatement(parameters, xse.Name));
            }
            else if (null != (argChoice = args.ContentTypeParticle as XmlSchemaChoice))
            {
                sb.Append("Execute").Append(xse.Name).Append("(").Append("anode_in").Append(");");
                GenerateExecuteMethod(xse.Name, argChoice);
            }
            else
            {
                sb.Append(string.Format("myTarget.{0}();", xse.Name));
            }
            
            return sb.ToString();
        }

        private string GenerateMethodCallStatement(IList<XmlSchemaElement> parameters, string p)
        {
            StringBuilder sb = new StringBuilder();
            sb.Append(string.Format("myTarget.{0}(", p));
            for (int i = 0; i < parameters.Count; i++)
            {
                if (i == parameters.Count - 1 && parameters.Count > 1)
                {
                    sb.Append(Constants.PARAM_SEPARATOR);
                }
                sb.Append(GetParameter(parameters[i]));
            }
            sb.Append(");");
            return sb.ToString();
        }

        private void GenerateExecuteMethod(string p, XmlSchemaChoice argChoice)
        {
            StringBuilder sb = new StringBuilder();
            sb.AppendLine(string.Format("\t\tpublic void Execute{0}(XmlNode anode_in)", p));
            sb.AppendLine("\t\t{");
            sb.AppendLine("\t\t\tint idx = GetOverLoadIndex(anode_in);");
            sb.AppendLine("\t\t\tswitch(idx)");
            sb.AppendLine("\t\t\t{");
            List<XmlSchemaObject> paramseq = argChoice.Items.Cast<XmlSchemaObject>().ToList<XmlSchemaObject>();
            XmlSchemaElement elem = null;
            XmlSchemaSequence seq = null;
            for (int i = 0; i < paramseq.Count; i++)
            {
                sb.AppendLine(string.Format("\t\t\t\tcase {0}:", i));
                sb.AppendLine("\t\t\t\t\t{");
                List<XmlSchemaElement> parameters = new List<XmlSchemaElement>();
                if (null != (seq = paramseq[i] as XmlSchemaSequence))
                {
                     parameters.AddRange(seq.Items.Cast<XmlSchemaElement>());
                }
                else if (null != (elem = paramseq[i] as XmlSchemaElement))
                {
                    parameters.Add(elem);
                }
                sb.Append(string.Format("\t\t\t\t\t\t{0}(", GenerateMethodCallStatement(parameters, p)));
                sb.AppendLine("\t\t\t\t\t\tbreak;");
                sb.AppendLine("\t\t\t\t\t}");
            }
            sb.AppendLine("\t\t\t}");
            sb.AppendLine("\t\t}");
            //Console.WriteLine(sb.ToString());
            myGeneratedMethods.Append(sb.ToString());
        }

        public string GetParameter(XmlSchemaElement paramDef_in)
        {
            string name = string.Empty;
            string type = "object";
            name = paramDef_in.Name;
            XmlSchemaComplexType param = paramDef_in.ElementSchemaType as XmlSchemaComplexType;
            List<XmlSchemaAttribute> atts = param.Attributes.Cast<XmlSchemaAttribute>().ToList<XmlSchemaAttribute>();
            type = (from att in atts where att.RefName.Name.Equals(Constants.PARAM_TYPE) select att.FixedValue).FirstOrDefault<string>();
            return string.Format("({0})(Variables[GetAttVal(anode_in[\"{1}\"], \"Name\")]", type, name);
        }

        private bool GetAttVal(XmlNode aNode_in, string p, ref string name)
        {
            bool ret = false;
            if (null != aNode_in.Attributes)
            {
                XmlAttribute att = aNode_in.Attributes[p];
                if (null != att)
                {
                    name = att.Value;
                    ret = true;
                }
            }
            return ret;
        }
    }
}